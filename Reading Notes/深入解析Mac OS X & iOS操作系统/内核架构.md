# 内核架构
内核架构的分类，其实是按照内核态、内核所在的内存空间和用户态进程的内存空间之间的共享程度来区分的。

## 1. 内核的分类
### 1.1 巨内核（内核空间和用户空间共享）
- 将所有的内核功能--线程调度、内存管理、文件系统、安全管理、设备驱动等都放到一起。
- 所有的功能都实现在同一内存空间中，并且这个地址空间还会映射到每一个进程的内存中。这样做的好处就是：内核态到用户态的切换效率非常高，基本上就是一次线程切换的开销。

### 1.2 微内核
微内核只包含核心代码--内存管理、任务调度。其他的功能全部交给外部的服务程序完成，并且服务程序之间完全隔离开，它们之间的所有通信都是通过消息传递来完成。这样做的好处有两点：

- 正确性，得益于两点：
	1. 代码量少。所以可以遍历代码验证其功能的正确性、稳定性和健壮性。
	2. 各个服务程序之间内存空间的隔离，因此，如果出现问题只重启出问题的服务就可以了。
- 灵活性：由于微内核的功能定义的非常好，所以移植到其他架构的工作比较简单直接。

缺点就是：性能。微内核的消息传递在底层需要通过内存复制操作以及数次的上下文切换来实现，而这些对计算速度的影响都不小。这一点太严重了，所以“纯粹”的微内核操作系统基本上只有学术意义。

### 1.3 混合内核
内核**最核心的部分**支持底层服务，包括：调度、进程间通信（IPC）和虚拟内存，这部分跟微内核一样。所有其他的服务都在这个核心之外，但是也在内核态中，而且和这个核心在同一个内存空间。**最核心的部分只能调用自己的组件、其他的服务则可以调内核的所有服务**。

## 2. 内核态
CPU通过设置特殊的寄存器来标记当前程序是是在何种模式下。

### 2.1 内核态/用户态的转换机制
- 自愿转换（应用程序要求内核服务的时候，即调用系统服务的时候可以进入内核态）
- 非自愿转换（发生异常、中断、处理陷阱的时候）

### 2.2 非自愿转换

#### 2.2.1 异常（Mach当中将所有异常都称作**陷阱**）
异常分为：错误、陷阱、终止。

#### 2.2.2 中断
中断能被分发出去的的条件：

- 对应的中断请求线当前不忙。
- 没有编号更低（编号越多优先级越高）的中断线的状态为忙。
- 本地CPU/处理器核心（通过底层CLI/STI汇编指令）禁用所有的中断。

#### 2.2.3 异常/中断的分发过程
![公共分发器][1]

### 2.3 自愿的内核转换

#### 2.3.1 模拟中断

#### 2.3.2 SYSENTER/SYSCALL

[1]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/exception-interruption.png?raw=true

