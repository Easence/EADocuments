# iOS卡顿监控

标签（空格分隔）： iOS

---

## 导致卡顿的原因
- 死锁：主线程拿到锁 A，需要获得锁 B，而同时某个子线程拿了锁 B，需要锁 A，这样相互等待就死锁了。
- 抢锁：主线程需要访问 DB，而此时某个子线程往 DB 插入大量数据。通常抢锁的体验是偶尔卡一阵子，过会就恢复了。
- 主线程大量 IO：主线程为了方便直接写入大量数据，会导致界面卡顿。
- 主线程大量计算：算法不合理，导致主线程某个函数占用大量 CPU。
- 大量的 UI 绘制：复杂的 UI、图文混排等，带来大量的 UI 绘制。

## 针对以上原因的应对方案
- 死锁一般会伴随 crash，可以通过 crash report 来分析。
- 抢锁不好办，将锁等待时间打出来用处不大，我们还需要知道是谁占了锁。
- 大量 IO 可以在函数开始结束打点，将占用时间打到日志中。
- 大量计算同理可以将耗时打到日志中。
- 大量 UI 绘制一般是必现，还好办；如果是偶现的话，想加日志点都没地方，因为是慢在系统函数里面。

## 最终方案
### 起一个子线程，监控主线程的活动情况，如果发现有卡顿，就将堆栈 dump 下来。

#### 具体到卡顿检测，有几个问题需要仔细处理：

- 怎么知道主线程发生了卡顿？
- 子线程以什么样的策略和频率来检测主线程？这个是要发布到现网的，如果处理不好，带来明显的性能损耗（尤其是电量），就不能接受了。
- 堆栈上报了上来怎么分类？直接用 crash report 的分类不适合。
-  卡顿 dump 下来的堆栈会有多频繁？数据量会有多大？
全量上报还是抽样上报？怎么在问题跟进与节省流量直接平衡？

#### 判断标准
1. 怎么判断主线程是不是发生了卡顿？一般来说，用户感受得到的卡顿大概有三个特征：
- FPS 降低
- CPU 占用率很高
- 主线程 Runloop 执行了很久

2. 看起来 FPS 能够兼容后面两个特征，但是在实际操作过程中发现 FPS 不好衡量，抖动比较大。而对于抢锁或大量IO的情况，光有CPU是不行的。所以我们实际上用到的是下面两个准则：
- CPU 占用超过了100%
- 主线程 Runloop 执行了超过2秒

3. 检测策略
为了降低检测带来的性能损耗，我们仔细设计了检测线程的策略：
- 内存 dump：每1秒检查一次，如果检查到主线程卡顿，就将所有线程的函数调用堆栈 dump 到内存中。
- 文件 dump：如果内存dump的堆栈跟上次捕捉到的不一样，则dump到文件中；否则按照斐波那契数列将检查时间递增（1，1，2，3，5，8…）直到没有遇到卡顿或卡顿堆栈不一样。这样能够避免同一个卡顿写入多个文件的情况，也能避免检测线程围着同一个卡顿空转的情况。

4. 分类方法
- 最外层归类：能够将同一入口的卡顿归类起来。缺点是层数不好定，可能外面十来层都是系统调用，也有可能第一层就是微信的函数了。
- 中间层归类：能够根据事先划分好的“特征值”来归类。缺点是“特征值”不好定，如果要做到自动学习生成的话，对后台分析系统要求太高了。
- 最内层归类：能够将同一原因的卡顿归类起来。缺点是同一分类可能包含不同的业务。

###### 要点提取自：[微信iOS卡顿监控系统][1]
###### 可参考的文章：[iOS实时卡顿监控][2]

[1]: http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=207890859&idx=1&sn=e98dd604cdb854e7a5808d2072c29162&scene=21#wechat_redirect
[2]: http://www.tanhao.me/code/151113.html/




